# -*- coding: utf-8 -*-
"""YGNK - SLNK - 10821 - DLMDSPWP01 â€“ Programming with Python.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1bINUFREuA4fAzcPyzqkb4W1xr7BHFE_J
"""

import pandas as pd

ideal_data = pd.read_csv('ideal.csv')
train_data = pd.read_csv('train.csv')
test_data = pd.read_csv('test.csv')

print("Ideal Data:")
print(ideal_data.head())
print("\nTrain Data:")
print(train_data.head())
print("\nTest Data:")
print(test_data.head())

import numpy as np

def find_best_fit_functions(train_data, ideal_data):
    best_fit_functions = {}
    for train_col in train_data.columns[1:]:
        min_deviation = float('inf')
        best_fit = None
        for ideal_col in ideal_data.columns[1:]:
            deviation = np.sum((train_data[train_col] - ideal_data[ideal_col]) ** 2)
            if deviation < min_deviation:
                min_deviation = deviation
                best_fit = ideal_col
        best_fit_functions[train_col] = best_fit
    return best_fit_functions

best_fit_functions = find_best_fit_functions(train_data, ideal_data)
print("Best Fit Functions:")
print(best_fit_functions)

deviation_thresholds = {}
for train_col in train_data.columns[1:]:
    ideal_col = best_fit_functions[train_col]
    max_deviation = np.max(np.abs(train_data[train_col] - ideal_data[ideal_col]))
    deviation_thresholds[train_col] = max_deviation * np.sqrt(2)

def map_test_data(test_data, ideal_data, best_fit_functions, deviation_thresholds):
    test_data['assigned_function'] = None
    test_data['deviation'] = None
    for i, row in test_data.iterrows():
        x = row['x']
        y = row['y']
        for train_col, ideal_col in best_fit_functions.items():
            ideal_y = ideal_data.loc[ideal_data['x'] == x, ideal_col].values[0]
            deviation = np.abs(y - ideal_y)
            if deviation <= deviation_thresholds[train_col]:
                test_data.at[i, 'assigned_function'] = ideal_col
                test_data.at[i, 'deviation'] = deviation
                break
    return test_data

mapped_test_data = map_test_data(test_data, ideal_data, best_fit_functions, deviation_thresholds)
print("Mapped Test Data:")
print(mapped_test_data)

import matplotlib.pyplot as plt

plt.figure(figsize=(12, 8))

for ideal_col in ideal_data.columns[1:]:
    plt.plot(ideal_data['x'], ideal_data[ideal_col], label=f'Ideal {ideal_col}', linestyle='dashed')

# Plot training data
for train_col in train_data.columns[1:]:
    plt.scatter(train_data['x'], train_data[train_col], label=f'Train {train_col}')

# Plot test data assignments
for i, row in mapped_test_data.iterrows():
    if pd.notnull(row['assigned_function']):
        plt.scatter(row['x'], row['y'], label=f'Test Assigned {row["assigned_function"]}', marker='x')

import unittest

class TestIdealFunctions(unittest.TestCase):
    def test_find_best_fit_functions(self):
        best_fit_functions = find_best_fit_functions(train_data, ideal_data)
        self.assertEqual(len(best_fit_functions), 4)

    def test_map_test_data(self):
        mapped_test_data = map_test_data(test_data, ideal_data, best_fit_functions, deviation_thresholds)
        self.assertIn('assigned_function', mapped_test_data.columns)
        self.assertIn('deviation', mapped_test_data.columns)

if __name__ == '__main__':
    unittest.main(argv=[''], exit=False)

from sqlalchemy import create_engine, Column, Integer, Float, String, MetaData, Table
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker

Base = declarative_base()

class TrainingData(Base):
    __tablename__ = 'training_data'
    id = Column(Integer, primary_key=True)
    x = Column(Float)
    y1 = Column(Float)
    y2 = Column(Float)
    y3 = Column(Float)
    y4 = Column(Float)

class IdealFunctions(Base):
    __tablename__ = 'ideal_functions'
    id = Column(Integer, primary_key=True)
    x = Column(Float)
    y1 = Column(Float)
    y2 = Column(Float)
    # Add columns up to y50
    # ...
    y50 = Column(Float)

class TestData(Base):
    __tablename__ = 'test_data'
    id = Column(Integer, primary_key=True)
    x = Column(Float)
    y = Column(Float)
    delta_y = Column(Float)
    ideal_function = Column(String)

engine = create_engine('sqlite:///functions.db')
Base.metadata.create_all(engine)

# Creating a session
Session = sessionmaker(bind=engine)
session = Session()

# Loading training data into the database
train_data.to_sql('training_data', engine, if_exists='replace', index=False)

# Loading ideal functions into the database
ideal_data.to_sql('ideal_functions', engine, if_exists='replace', index=False)

deviation_thresholds = {}
for train_col in train_data.columns[1:]:
    ideal_col = best_fit_functions[train_col]
    max_deviation = np.max(np.abs(train_data[train_col] - ideal_data[ideal_col]))
    deviation_thresholds[train_col] = max_deviation * np.sqrt(2)

def map_test_data(test_data, ideal_data, best_fit_functions, deviation_thresholds):
    mapped_test_data = []
    for i, row in test_data.iterrows():
        x = row['x']
        y = row['y']
        for train_col, ideal_col in best_fit_functions.items():
            ideal_y = ideal_data.loc[ideal_data['x'] == x, ideal_col].values[0]
            deviation = np.abs(y - ideal_y)
            if deviation <= deviation_thresholds[train_col]:
                mapped_test_data.append((x, y, deviation, ideal_col))
                break
    return mapped_test_data

mapped_test_data = map_test_data(test_data, ideal_data, best_fit_functions, deviation_thresholds)

mapped_test_df = pd.DataFrame(mapped_test_data, columns=['x', 'y', 'delta_y', 'ideal_function'])
mapped_test_df.to_sql('test_data', engine, if_exists='replace', index=False)
print(mapped_test_df)

from bokeh.plotting import figure, show, output_file
from bokeh.io import output_notebook
from bokeh.models import ColumnDataSource

output_notebook()

train_source = ColumnDataSource(train_data)
ideal_source = ColumnDataSource(ideal_data)
test_source = ColumnDataSource(mapped_test_df)

p = figure(title="Training Data, Ideal Functions, and Test Data Assignments", x_axis_label='x', y_axis_label='y')

for col in train_data.columns[1:]:
    p.scatter('x', col, source=train_source, legend_label=f'Train {col}')

# Plot ideal functions
for col in ideal_data.columns[1:]:
    p.line('x', col, source=ideal_source, legend_label=f'Ideal {col}', line_dash='dashed')

# Plot test data assignments
p.scatter('x', 'y', source=test_source, legend_label='Test Data', color='red', marker='x')

show(p)

class TestIdealFunctions(unittest.TestCase):
    def test_find_best_fit_functions(self):
        best_fit_functions = find_best_fit_functions(train_data, ideal_data)
        self.assertEqual(len(best_fit_functions), 4)

    def test_map_test_data(self):
        mapped_test_data = map_test_data(test_data, ideal_data, best_fit_functions, deviation_thresholds)
        self.assertIn('assigned_function', mapped_test_data.columns)
        self.assertIn('deviation', mapped_test_data.columns)

if __name__ == '__main__':
    unittest.main(argv=[''], exit=False)

class DataProcessingError(Exception):
    """Custom exception for data processing errors."""
    pass

def load_data(file_path):
    try:
        return pd.read_csv(file_path)
    except FileNotFoundError:
        raise DataProcessingError(f"File not found: {file_path}")
    except pd.errors.EmptyDataError:
        raise DataProcessingError(f"No data: {file_path}")

def main():
    try:
        ideal_data = load_data('ideal.csv')
        train_data = load_data('train.csv')
        test_data = load_data('test.csv')

        best_fit_functions = find_best_fit_functions(train_data, ideal_data)
        mapped_test_data = map_test_data(test_data, ideal_data, best_fit_functions, deviation_thresholds)

        # Save to database
        train_data.to_sql('training_data', engine, if_exists='replace', index=False)
        ideal_data.to_sql('ideal_functions', engine, if_exists='replace', index=False)
        mapped_test_df = pd.DataFrame(mapped_test_data, columns=['x', 'y', 'delta_y', 'ideal_function'])
        mapped_test_df.to_sql('test_data', engine, if_exists='replace', index=False)

        # Visualize the data
        visualize_data(train_data, ideal_data, mapped_test_df)

    except DataProcessingError as e:
        print(e)
    except Exception as e:
        print(f"An unexpected error occurred: {e}")

if __name__ == '__main__':
    main()

import subprocess

repository_url = "<repository_url>"
repository_name = "<repository_name>"
feature_branch = "feature/new_function"
commit_message = "Add new function to improve feature X"

def run_git_command(command):
    """Run a Git command and print the output."""
    process = subprocess.Popen(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    stdout, stderr = process.communicate()
    if process.returncode == 0:
        print(stdout.decode('utf-8'))
    else:
        print(stderr.decode('utf-8'))

run_git_command(f"git clone {repository_url}")
run_git_command(f"cd {repository_name} && git checkout develop")

run_git_command(f"cd {repository_name} && git checkout -b {feature_branch}")



run_git_command(f"cd {repository_name} && git add .")
run_git_command(f"cd {repository_name} && git commit -m \"{commit_message}\"")

run_git_command(f"cd {repository_name} && git push origin {feature_branch}")

print("Now, go to my repository on the Git hosting service (e.g., GitHub) to create a pull request from your 'feature/new_function' branch into the 'develop' branch.")